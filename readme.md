# Haskell

## 入门

* `==`运算子仅对两个可比较的值可用，要求他们的型别都必须一致，苹果和橘子就无法做比较
* 中缀函数：用两个参数将它夹在中央，eg: *
* 前缀函数：其他大多数不能与数夹在一起的函数则被称作前缀函数，绝大部分函数都是前缀函数
* 在Haskell中，函数调用的形式是函数名，空格，空格分隔的参数表,并且函数调用拥有最高的优先级 eg:succ 8；min 9 10; min 3.4 3.2;
	
    	// Haskell中，函数的调用使用空格
    	bar (bar 3)
    	// =>bar(bar(3))

* Haskell中的函数没有顺序，所以声明函数的顺序不同的作用是等价的
* Haskell的if语句

	```
	// Haskell 中 if 语句的 else 部分是不可省略。在命令式语言中，你可以通过 if 语句来跳过一段代码，而在 Haskell 中，每个函数和表达式都要返回一个结果
	// Haskell 中的 if 语句的另一个特点就是它其实是个表达式，表达式就是返回一个值的一段代码
	// 正由于 else 是强制的，if 语句一定会返回某个值，所以说 if 语句也是个表达式
	//eg:
	doubleSmallNumber x = (if x > 200 then x else x * 2) + 1
	```

* Haskell命名

	```
	函数名中有单引号，没有任何的特殊含义，只是一个函数名的合法字符，通常，我们使用单引号来区分一个稍经修改但差别不大的函数
	
	conanO'Brien = "It's a-me, Conan O'Brien!"(这是一个函数)

	首字母大写的函数是不允许的，没有参数的函数通常被称为“定义”(或者是“名字”),一旦定义，就与字符串完全等价，并且不可以修改它的值
	```

* List

	> 在 Haskell 中，List 就像现实世界中的购物单一样重要。它是最常用的数据结构，并且十分强大，灵活地使用它可以解决很多问题。本节我们将对 List，字串和 list comprehension 有个初步了解。 在 Haskell 中，List 是一种单型别的数据结构，可以用来存储多个型别相同的元素。我们可以在里面装一组数字或者一组字符，但不能把字符和数字装在一起

	在ghci下可以用`let`来定义一个常量let

	一个 List 由方括号括起，其中的元素用逗号分隔开来`[1,2,3]`必须要同一个数据类型

	字符串实际上就是一组字符的List，"hello",['h','e','l','l','o'] 的语法糖而已

	将两个List合并是很常见的操作，可以通过`++`运算子来实现

	在使用 ++ 运算子处理长字串时要格外小心(对长 List 也是同样)，Haskell 会遍历整个的 List(++ 符号左边的那个)。在处理较短的字串时问题还不大，但要是在一个 5000 万长度的 List 上追加元素，那可得执行好一会儿了。所以说，用 : 运算子往一个 List 前端插入元素会是更好的选择

	: 运算子可以连接一个元素到一个 List 或者字串之中，而 ++ 运算子则是连接两个 List。若要使用 ++ 运算子连接单个元素到一个 List 之中，就用方括号把它括起使之成为单个元素的 List。[1,2,3] 实际上是 1:2:3:[] 的语法糖。[] 表示一个空 List,若要从前端插入 3，它就成了 [3], 再插入 2，它就成了 [2,3]，以此类推

	[],[[]],[[],[],[]] 第一个是一个空的 List，第二个是含有一个空 List 的 List，第三个是含有三个空 List 的 List

	若是要按照索引取得 List 中的元素，可以使用 !! 运算子，索引的下标为 0

	但是不能超过List的长度

	List 中的 List 可以是不同长度，但必须得是相同的型别。如不可以在 List 中混合放置字符和数组相同，混合放置数值和字符的 List 也是同样不可以的。当 List 内装有可比较的元素时，使用 > 和 >= 可以比较 List 的大小。它会先比较第一个元素，若它们的值相等，则比较下一个，以此类推

	`head` 返回一个 List 的头部，也就是 List 的首个元素。

	`tail` 返回一个 List 的尾部，也就是 List 除去头部之后的部分

	`last` 返回一个 List 的最后一个元
	素。

	`init` 返回一个 List 除去最后一个元素的部分

	在使用 head，tail，last 和 init 时要小心别用到空的 List 上，这个错误不会在编译时被捕获。所以说做些工作以防止从空 List 中取值会是个好的做法

	`length`返回一个 List 的长度

	`null` 检查一个 List 是否为空。如果是，则返回 True，否则返回 False。应当避免使用 xs==[] 之类的语句来判断 List 是否为空，使用 null 会更好

	`reverse` 将一个 List 反转

	`take` 返回一个 List 的前几个元素
	
	若是图取超过 List 长度的元素个数，只能得到原 List。若 take 0 个元素，则会得到一个空 List

	`drop` 会删除一个List中的前几个元素

	`maximum` 返回一个List中最大的那个元素

	`minimum` 返回一个List中最小的那个元素

	`sum` 返回一个 List 中所有元素的和。
	
	`product`返回一个 List 中所有元素的积

	`elem` 判断一个元素是否在包含于一个 List，通常以中缀函数的形式调用它

* Range

	Range 是构造 List 方法之一，而其中的值必须是可枚举的

	Range 的特点是他还允许你指定每一步该跨多远。譬如说，今天的问题换成是要得到 1 到 20 间所有的偶数或者 3 的倍数该怎样？

	 `[2,4..20]`

	 `[3,6..20]`

	 避免在Range中使用浮点数

	 你也可以不标明 Range 的上限，从而得到一个无限长度的 List。在后面我们会讲解关于无限 List 的更多细节。取前 24 个 13 的倍数该怎样？恩，你完全可以 [13,26..24*13]，但有更好的方法： take 24 [13,26..]

	 由于 Haskell 是惰性的，它不会对无限长度的 List 求值，否则会没完没了的。它会等着，看你会从它那儿取多少。在这里它见你只要 24 个元素，便欣然交差

	 cycle 接受一个 List 做参数并返回一个无限 List 

	 repeat 接受一个值作参数，并返回一个仅包含该值的无限 List。这与用 cycle 处理单元素 List 差不多。

	 其实，你若只是想得到包含相同元素的 List ，使用 replicate 会更简单，如 replicate 3 10，得 [10,10,10]


* List Comprehension

	
	Set Comprehension 也就是数学的集合，List Comprehension就是类似于Set Comprehension的一种结构
	

	从一个list中筛选出符合特定限制条件的操作也可以称为过滤，即取一组数组并且按照一定的限制条件过滤它们

	也可以加多个限制条件。若要达到 10 到 20 间所有不等于 13，15 或 19 的数
	
	`[ x | x <- [10..20], x /= 13, x /= 15, x /= 19]`

	除了多个限制条件之外，从多个 List 中取元素也是可以的

	`[ x*y | x <- [2,5,10], y <- [8,10,11]]`

* Tuble

	Tuble(元组)很像LIst，都是将多个值存入一个个体的容器，但是有着本质的不同，一组数字的List就是一组数字，他们的型别相同，且不关心其中包含元素的数量

	而 Tuple 则要求你对需要组合的数据的数目非常的明确，它的型别取决于其中项的数目与其各自的型别。Tuple 中的项由括号括起，并由逗号隔开。

	另外的不同之处就是 Tuple 中的项不必为同一型别，在 Tuple 里可以存入多态别项的组合

	动脑筋，在 Haskell 中表示二维矢量该如何？使用 List 是一种方法，它倒也工作良好。若要将一组矢量置于一个 List 中来表示平面图形又该怎样？我们可以写类似 [[1,2],[8,11],[4,5]] 的代码来实现。但问题在于，[[1,2],[8,11,5],[4,5]] 也是同样合法的，因为其中元素的型别都相同。尽管这样并不靠谱，但编译时并不会报错。然而一个长度为 2 的 Tuple (也可以称作序对，Pair) ，是一个独立的类型，这便意味着一个包含一组序对的 List 不能再加入一个三元组，所以说把原先的方括号改为圆括号使用 Tuple 会 更好: [(1,2),(8,11),(4,5)]

	使用 Tuple 前应当事先明确一条数据中应该由多少个项。每个不同长度的 Tuple 都是独立的型别，所以你就不可以写个函数来给它追加元素。而唯一能做的，就是通过函数来给一个 List 追加序对，三元组或是四元组等内容。


	`fst`返回一个序对的首项
	`snd`返回序队的尾项

	`zip`用来生成一组序对(Pair)的list，它取两个list，然后将它们交叉配对，形成一组序对的 List

	Haskell是惰性的，较长的那个会在中间断开，去匹配较短的那个。由于 Haskell 是惰性的，使用 zip 同时处理有限和无限的 List 也是可以的

	`zip [1..] ["apple", "orange", "cherry", "mango"]`
	
	**函数式编程语言的一般思路： 先取一个初始的集合并将其变形，执行过滤条件，最终取得正确的结果**


## 类型和类型类


Haskell中万物都有类型，因此在执行编译之时编译器可以大有作为，和java不同
Haskell支持类型推导，所以我们不必在每个函数或表达式上都标明其类型了

类型是每个表达式都有的某种标签，它标明了这一表达式所属的范畴

在 ghci 中 使用`:t`命令后跟任何可用的表达式，即可得到该表达式的类型


函数也有类型，编写函数时，给他一个明确的类型声明是一个好习惯

```
addThree :: Int -> Int -> Int -> Int   
addThree x y z = x + y + z
```
参数之间用->分隔，而与返回值之间并无差异，返回值是最后一项，参数就是前三项

常见的几个类型

* Int 整数 Int是有界的
* Integer 整数，是无界的
* Float 表示单精度的浮点数
* Double 表示双精度的浮点数
* Bool 表示布尔值
* Char 表示一个字符

凡是类型其首字母必大写，所以意味着a可以是任意的类型

**类型类**

类型定义行为的接口，如果一个类型属于某类型类，那它必实现了
该类型类所描述的行为

```
ghci> :t (==)   
(==) :: (Eq a) => a -> a -> Bool
```

`=>`符号，它左边的部分叫做类型约束，“相等函数取两个相同类型的值作为参数并返回一个布尔值，而这两个参数的类型同在Eq类之中”

几个基本的类型类

* Eq 包含可判断相等性的类型，除了函数以外的所有类型等属于Eq
* Ord包含可比较大小的类型，除了函数以外
* Show的成员为可用字符串表示的类型，除函数以外的所有类型都是Show的成员 最常用的函数表示show,可以取任意Show的成员类型并将其转为字符串
* Read与Show相反的类型类，read函数可以将一个字符串转为Read的某成员类型
* Enum的成员是连续的类型-也就是可枚举，Enum类存在的主要好处就在于我们可以在Range中用到它的成员类型：每个值都有后继子(successer)和前置子(predecesor)，分别可以通过succ函数和pred函数得到
* Bounded的成员都有一个上下限制
* Num 表示数字的类型类，它的成员类型都具有数字的特征
* Integral同样是表示数字的类型类。Num包含所有的数字：实数和整数。而Intgral仅包含整数，其中的成员类型有Int和Intege
* Floating仅包含浮点类型：Float和Double。